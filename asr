#!/usr/bin/env bash
# asr — thin wrapper: run asr.js ONCE for a folder or a single file
# Options (passed through to asr.js) must come BEFORE the target path.
# Usage:
#   asr [opts...]                      # run in CWD (folder mode)
#   asr [opts...] PARAM                # run PARAM (dir or file; abs, ~, ./, ../, or BASE_MEDIA/name)
#   asr tail   [PARAM]
#   asr kill   [PARAM]
#   asr status [PARAM]
#   asr last   [PARAM]
#   asr log    [PARAM]                 # prints log path
#
# Notes:
# - Shared files per target dir: asr.log, asr.pid (exit code is printed into asr.log)
# - Node runs from /usr/local/lib/asr; temps in /tmp; secrets there too.

set -euo pipefail

BASE_MEDIA="/mnt/media/tv"
RUNTIME_DIR="/usr/local/lib/asr"
ASR_JS_PATH="$RUNTIME_DIR/asr.js"

# Robust PATH
PATH="${PATH:-/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin}"
NODE_BIN="$(command -v node || true)"; [[ -x "$NODE_BIN" ]] || NODE_BIN="node"

# Runtime env
TMPDIR="/tmp"; export TMPDIR TMP="$TMPDIR" TEMP="$TMPDIR"
ASR_TMPDIR="/tmp/asr-$PPID"; export ASR_TMPDIR
ASR_SECRETS_DIR="$RUNTIME_DIR/secrets"; export ASR_SECRETS_DIR

# ---------- helpers ----------
resolve_path() {
  local p="$1"
  if [[ -z "$p" ]]; then
    printf '%s' "$PWD"
  elif [[ "$p" = /* ]]; then
    printf '%s' "$p"
  elif [[ "$p" = ~* ]]; then
    # shellcheck disable=SC2086
    printf '%s' "$(eval echo "$p")"
  elif [[ "$p" == ./* || "$p" == ../* ]]; then
    printf '%s' "$(realpath -m -- "$PWD/$p")"
  else
    printf '%s' "$BASE_MEDIA/$p"
  fi
}

start_tail() { [[ -f "$LOG_FILE" ]] || { echo "No log at $LOG_FILE"; exit 1; }; exec tail -fn 200 "$LOG_FILE"; }

is_running() {
  [[ -f "$PID_FILE" ]] || return 1
  local pid; pid="$(cat "$PID_FILE" 2>/dev/null || true)"
  [[ -n "${pid:-}" ]] && kill -0 "$pid" 2>/dev/null
}

cleanup_stale_pid() { if [[ -f "$PID_FILE" ]] && ! is_running; then rm -f "$PID_FILE"; fi; }

kill_run() {
  local pid=""; [[ -f "$PID_FILE" ]] && pid="$(cat "$PID_FILE" 2>/dev/null || true)"
  if [[ -z "${pid:-}" ]] || ! kill -0 "$pid" 2>/dev/null; then
    echo "No asr running"; rm -f "$PID_FILE"; exit 0
  fi
  echo "SIGTERM to process-group $pid"; kill -TERM "-$pid" 2>/dev/null || true; sleep 1
  kill -0 "$pid" 2>/dev/null && { echo "SIGKILL to process-group $pid"; kill -KILL "-$pid" 2>/dev/null || true; }
  rm -f "$PID_FILE"; echo "Stopped."
}

last_exit_from_log() {
  [[ -f "$LOG_FILE" ]] || { echo "no log in: $TARGET_DIR"; return 1; }
  local code
  code="$(awk '/^\[asr\] EXIT [0-9]+$/ {c=$3} END{if (c!="") print c;}' "$LOG_FILE" || true)"
  if [[ -n "${code:-}" ]]; then echo "last exit: $code in: $TARGET_DIR"; else echo "no previous exit code recorded in: $TARGET_DIR"; return 1; fi
}

show_log_path() { [[ -f "$LOG_FILE" ]] && echo "$LOG_FILE" || { echo "No log at $LOG_FILE"; return 1; }; }

usage() {
  cat <<EOF
asr — run asr.js once on a folder or single file

Usage:
  asr [opts...]             Run in current directory (folder mode)
  asr [opts...] PARAM       Run PARAM (dir or file). Absolute, ~, ./, ../ allowed. Bare names map to $BASE_MEDIA/PARAM
  asr tail|kill|status|last|log [PARAM]

Examples:
  asr --test-mins=10 "Ideal/Season 7/ideal.s07e01.dvdrip.xvid-haggis.avi"
  asr --test-mins=10 /mnt/media/archive/dev/apps/mistral-asr/test/Karen\\ Pirie\\ S01E01\\ 1080p\\ ITV\\ WEB-DL\\ AAC\\ 2.0\\ H.264-WhiskeyJack.mkv
  asr tail "Ideal/Season 7"
Notes:
  - Place options BEFORE the target path.
  - If your path has spaces, quote it.
EOF
}

# ---------- parse args ----------
subcmd=""
opts=()
param=""

if (( $# >= 1 )); then
  case "$1" in
    tail|kill|status|last|log|help|-h|--help)
      subcmd="$1"; shift
      # For utility subcommands, we do not parse options; remaining single arg is the target (optional)
      param="${1-}"
      ;;
    *)
      # Main run: collect leading --options for asr.js until the first non-option (target)
      while (( $# )); do
        case "$1" in
          --) shift; break ;;                         # explicit end of options; next token is target
          --*) opts+=("$1"); shift ;;                 # collect asr.js options
          *) param="$1"; shift; break ;;              # first non-option is target
        esac
      done
      # If anything else remains after target, it likely means an unquoted path with spaces.
      if (( $# )); then
        echo "ERROR: multiple non-option arguments detected. If your path has spaces, wrap it in quotes." >&2
        exit 2
      fi
      ;;
  esac
fi

# Resolve PARAM to a path, detect mode
TARGET_PATH="$(resolve_path "${param:-}")"
MODE="dir"
TARGET_DIR="$TARGET_PATH"
INPUT_PATH="$TARGET_PATH"
if [[ -e "$TARGET_PATH" && ! -d "$TARGET_PATH" ]]; then
  MODE="file"
  TARGET_DIR="$(dirname "$TARGET_PATH")"
  INPUT_PATH="$TARGET_PATH"
fi

# Unified filenames
LOG_FILE="$TARGET_DIR/asr.log"
PID_FILE="$TARGET_DIR/asr.pid"

# ---------- subcommands ----------
case "$subcmd" in
  help|-h|--help) usage; exit 0 ;;
  tail)
    [[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }
    start_tail ;;
  kill)
    [[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }
    kill_run; exit 0 ;;
  status)
    [[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }
    if is_running; then echo "asr is running (PID $(cat "$PID_FILE")) in: $TARGET_DIR"; else echo "asr is NOT running in: $TARGET_DIR"; [[ -f "$PID_FILE" ]] && echo "(stale PID file present: $PID_FILE)"; fi
    exit 0 ;;
  last)
    [[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }
    last_exit_from_log; exit $? ;;
  log)
    [[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }
    show_log_path; exit $? ;;
esac

# ---------- main run ----------
[[ -f "$ASR_JS_PATH" ]] || { echo "ERROR: asr.js not found at $ASR_JS_PATH"; exit 1; }
[[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }

cleanup_stale_pid
if is_running; then
  echo "asr already running in: $TARGET_DIR (PID $(cat "$PID_FILE"))"
  echo "Use: asr tail \"$param\"  |  asr kill \"$param\""
  exit 1
fi

echo "Mode: $MODE"
echo "Input: $INPUT_PATH"
echo "Target dir: $TARGET_DIR"
echo "Writing log to: $LOG_FILE"
echo "Using temp dir: $TMPDIR (ASR_TMPDIR=$ASR_TMPDIR)"
echo "asr.js: $ASR_JS_PATH"
if ((${#opts[@]})); then printf 'Passing options to asr.js: %q\n' "${opts[@]}"; fi

trap 'rm -f "$PID_FILE" >/dev/null 2>&1 || true' EXIT

# Export minimal vars for subshell; pass options via quoted array expansion
export ASR_MODE="$MODE"
export ASR_INPUT="$INPUT_PATH"
export ASR_NODE_BIN="$NODE_BIN"
export ASR_JS_ENTRY="$ASR_JS_PATH"
export ASR_PID_FILE="$PID_FILE"
export ORIGINAL_PWD="$TARGET_DIR"

# shell-safe: serialize opts into one var to re-expand inside subshell
# (uses printf %q to preserve spaces/equals; read -r -a recovers array)
ASR_OPTS_SERIALIZED="$(printf '%q ' "${opts[@]:-}")"; export ASR_OPTS_SERIALIZED

{ set -o pipefail; setsid bash -c '
    set -euo pipefail
    echo $$ > "$ASR_PID_FILE"
    export TMPDIR="/tmp" TMP="/tmp" TEMP="/tmp"
    export ASR_TMPDIR ASR_SECRETS_DIR ORIGINAL_PWD
    cd "'"$RUNTIME_DIR"'"
    # recover options array
    read -r -a _OPTS <<< "${ASR_OPTS_SERIALIZED:-}"
    echo "[asr] (start) $ASR_MODE: $ASR_INPUT"
    exec "$ASR_NODE_BIN" "$ASR_JS_ENTRY" "${_OPTS[@]}" --input "$ASR_INPUT"
  ' asr-batch 2>&1 | tee -a "$LOG_FILE"; } &

runner_pid=$!
echo "$runner_pid" > "$PID_FILE"
echo "Runner PID: $(cat "$PID_FILE") (PID file: $PID_FILE)"
echo "Tip: asr tail [PARAM]  |  asr kill [PARAM]  |  asr last [PARAM]  |  asr log [PARAM]"

wait "$runner_pid"
status=$?
echo "[asr] EXIT $status" | tee -a "$LOG_FILE"
rm -f "$PID_FILE"
exit "$status"
