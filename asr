#!/usr/bin/env bash
# asr — thin wrapper: run asr.js ONCE for a folder or a single file
# Usage:
#   asr [opts...]                 # run in CWD (folder mode)
#   asr [opts...] PARAM           # run PARAM (dir or file; abs, ~, ./, ../, or BASE_MEDIA/name)
#   asr tail   [PARAM]
#   asr kill   [PARAM]
#   asr status [PARAM]
#   asr last   [PARAM]            # reads last exit code from asr.log
#   asr log    [PARAM]            # prints the log path
#
# Notes:
# - Shared files per target dir: asr.log, asr.pid (exit code logged as "[asr] EXIT N")
# - Node executes from /usr/local/lib/asr so node_modules & secrets resolve there
# - Temps in /tmp via ASR_TMPDIR
# - Safe to close the launching terminal or press Ctrl-C; run continues in background

set -euo pipefail

BASE_MEDIA="/mnt/media/tv"
RUNTIME_DIR="/usr/local/lib/asr"
ASR_JS_PATH="$RUNTIME_DIR/asr.js"

# Robust PATH for non-interactive shells
PATH="${PATH:-/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin}"
NODE_BIN="$(command -v node || true)"; [[ -x "$NODE_BIN" ]] || NODE_BIN="node"

# Runtime env
TMPDIR="/tmp"; export TMPDIR TMP="$TMPDIR" TEMP="$TMPDIR"
ASR_TMPDIR="/tmp/asr-$PPID"; export ASR_TMPDIR
ASR_SECRETS_DIR="$RUNTIME_DIR/secrets"; export ASR_SECRETS_DIR

# ---------- helpers ----------
resolve_path() {
  local p="$1"
  if [[ -z "$p" ]]; then
    printf '%s' "$PWD"
  elif [[ "$p" = /* ]]; then
    printf '%s' "$p"
  elif [[ "$p" = ~* ]]; then
    # shellcheck disable=SC2086
    printf '%s' "$(eval echo "$p")"
  elif [[ "$p" == ./* || "$p" == ../* ]]; then
    printf '%s' "$(realpath -m -- "$PWD/$p")"
  else
    printf '%s' "$BASE_MEDIA/$p"
  fi
}

start_tail() { [[ -f "$LOG_FILE" ]] || { echo "No log at $LOG_FILE"; exit 1; }; exec tail -fn 200 "$LOG_FILE"; }

is_running() {
  [[ -f "$PID_FILE" ]] || return 1
  local pid; pid="$(cat "$PID_FILE" 2>/dev/null || true)"
  [[ -n "${pid:-}" ]] && kill -0 "$pid" 2>/dev/null
}

cleanup_stale_pid() { if [[ -f "$PID_FILE" ]] && ! is_running; then rm -f "$PID_FILE"; fi; }

kill_run() {
  local pid=""; [[ -f "$PID_FILE" ]] && pid="$(cat "$PID_FILE" 2>/dev/null || true)"
  if [[ -z "${pid:-}" ]] || ! kill -0 "$pid" 2>/dev/null; then
    echo "No asr running"; rm -f "$PID_FILE"; exit 0
  fi
  echo "SIGTERM to process-group $pid"; kill -TERM "-$pid" 2>/dev/null || true; sleep 1
  kill -0 "$pid" 2>/dev/null && { echo "SIGKILL to process-group $pid"; kill -KILL "-$pid" 2>/dev/null || true; }
  rm -f "$PID_FILE"; echo "Stopped."
}

last_exit_from_log() {
  [[ -f "$LOG_FILE" ]] || { echo "no log in: $TARGET_DIR"; return 1; }
  local code
  code="$(awk '/^\[asr\] EXIT [0-9]+$/ {c=$3} END{if (c!="") print c;}' "$LOG_FILE" || true)"
  if [[ -n "${code:-}" ]]; then echo "last exit: $code in: $TARGET_DIR"; else echo "no previous exit code recorded in: $TARGET_DIR"; return 1; fi
}

show_log_path() { [[ -f "$LOG_FILE" ]] && echo "$LOG_FILE" || { echo "No log at $LOG_FILE"; return 1; }; }

usage() {
  cat <<EOF
asr — run asr.js once on a folder or single file

Usage:
  asr [opts...]             Run in current directory (folder mode)
  asr [opts...] PARAM       Run PARAM (dir or file). Absolute, ~, ./, ../ allowed. Bare names map to $BASE_MEDIA/PARAM
  asr tail|kill|status|last|log [PARAM]

Examples:
  asr --test-mins=10 "Ideal/Season 7/ideal.s07e01.dvdrip.xvid-haggis.avi"
  asr --test-mins=10 "/absolute/path/Some Video.mkv"
Notes:
  - Place options BEFORE the target path.
  - If your path has spaces, quote it.
EOF
}

# ---------- parse args ----------
subcmd=""
opts=()
param=""

if (( $# >= 1 )); then
  case "$1" in
    tail|kill|status|last|log|help|-h|--help)
      subcmd="$1"; shift
      param="${1-}"   # optional target for utility subcommands
      ;;
    *)
      # Main run: collect leading --options for asr.js until first non-option (target)
      while (( $# )); do
        case "$1" in
          --) shift; break ;;                         # explicit end of options; next token is target
          --*) opts+=("$1"); shift ;;                 # collect asr.js options
          *) param="$1"; shift; break ;;              # first non-option is target
        esac
      done
      # If anything else remains after target, it's likely an unquoted path with spaces.
      if (( $# )); then
        echo "ERROR: multiple non-option arguments detected. If your path has spaces, wrap it in quotes." >&2
        exit 2
      fi
      ;;
  esac
fi

# Resolve target & mode
TARGET_PATH="$(resolve_path "${param:-}")"
MODE="dir"
TARGET_DIR="$TARGET_PATH"
INPUT_PATH="$TARGET_PATH"
if [[ -e "$TARGET_PATH" && ! -d "$TARGET_PATH" ]]; then
  MODE="file"
  TARGET_DIR="$(dirname "$TARGET_PATH")"
  INPUT_PATH="$TARGET_PATH"
fi

# Unified filenames per target dir
LOG_FILE="$TARGET_DIR/asr.log"
PID_FILE="$TARGET_DIR/asr.pid"

# ---------- subcommands ----------
case "$subcmd" in
  help|-h|--help) usage; exit 0 ;;
  tail)
    [[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }
    start_tail ;;
  kill)
    [[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }
    kill_run; exit 0 ;;
  status)
    [[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }
    if is_running; then echo "asr is running (PID $(cat "$PID_FILE")) in: $TARGET_DIR"; else echo "asr is NOT running in: $TARGET_DIR"; [[ -f "$PID_FILE" ]] && echo "(stale PID file present: $PID_FILE)"; fi
    exit 0 ;;
  last)
    [[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }
    last_exit_from_log; exit $? ;;
  log)
    [[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }
    show_log_path; exit $? ;;
esac

# ---------- main run ----------
[[ -f "$ASR_JS_PATH" ]] || { echo "ERROR: asr.js not found at $ASR_JS_PATH"; exit 1; }
[[ -e "$TARGET_PATH" || -d "$TARGET_DIR" ]] || { echo "ERROR: target not found: $TARGET_PATH"; exit 1; }

cleanup_stale_pid
if is_running; then
  echo "asr already running in: $TARGET_DIR (PID $(cat "$PID_FILE"))"
  echo "Use: asr tail \"$param\"  |  asr kill \"$param\""
  exit 1
fi

echo "Mode: $MODE"
echo "Input: $INPUT_PATH"
echo "Target dir: $TARGET_DIR"
echo "Writing log to: $LOG_FILE"
echo "Using temp dir: $TMPDIR (ASR_TMPDIR=$ASR_TMPDIR)"
echo "asr.js: $ASR_JS_PATH"
if ((${#opts[@]})); then printf 'Passing options to asr.js: %q\n' "${opts[@]}"; fi

# Export for the subshell (needed by tee and pid handling)
export ASR_MODE ASR_INPUT ASR_NODE_BIN ASR_JS_ENTRY ASR_PID_FILE ORIGINAL_PWD
ASR_MODE="$MODE"
ASR_INPUT="$INPUT_PATH"
ASR_NODE_BIN="$NODE_BIN"
ASR_JS_ENTRY="$ASR_JS_PATH"
ASR_PID_FILE="$PID_FILE"
ORIGINAL_PWD="$TARGET_DIR"
export LOG_FILE PID_FILE TARGET_DIR

# Option passing:
if ((${#opts[@]})); then
  ASR_OPTS_SERIALIZED="$(printf '%q ' "${opts[@]}")"; export ASR_OPTS_SERIALIZED
  export ASR_HAS_OPTS="1"
else
  unset ASR_OPTS_SERIALIZED || true
  unset ASR_HAS_OPTS || true
fi

# ====== RUN: tee lives INSIDE the detached session; child handles cleanup ======
setsid bash -c '
  set -euo pipefail
  # Ignore hangups / Ctrl-C in this detached session
  trap "" HUP INT
  # Always log exit code and clear the pid on any exit path
  trap "st=\$?; echo \"[asr] EXIT \$st\" | tee -a \"\$LOG_FILE\"; rm -f \"\$ASR_PID_FILE\"; exit \$st" EXIT

  # fully detach from any terminal input
  exec </dev/null

  echo $$ > "$ASR_PID_FILE"
  export TMPDIR="/tmp" TMP="/tmp" TEMP="/tmp"
  export ASR_TMPDIR ASR_SECRETS_DIR ORIGINAL_PWD LOG_FILE ASR_PID_FILE

  cd "'"$RUNTIME_DIR"'"

  if [[ "${ASR_HAS_OPTS:-}" = "1" ]]; then
    read -r -a _OPTS <<< "${ASR_OPTS_SERIALIZED:-}"
    # Log argv
    { printf "[asr] exec: "; printf "%q " "$ASR_NODE_BIN" "$ASR_JS_ENTRY" "${_OPTS[@]}" "$ASR_INPUT"; printf "\n"; } | tee -a "$LOG_FILE"
    echo "[asr] (start) $ASR_MODE: $ASR_INPUT" | tee -a "$LOG_FILE"
    ( "$ASR_NODE_BIN" "$ASR_JS_ENTRY" "${_OPTS[@]}" "$ASR_INPUT" ) 2>&1 | tee -a "$LOG_FILE"
  else
    { printf "[asr] exec: "; printf "%q " "$ASR_NODE_BIN" "$ASR_JS_ENTRY" "$ASR_INPUT"; printf "\n"; } | tee -a "$LOG_FILE"
    echo "[asr] (start) $ASR_MODE: $ASR_INPUT" | tee -a "$LOG_FILE"
    ( "$ASR_NODE_BIN" "$ASR_JS_ENTRY" "$ASR_INPUT" ) 2>&1 | tee -a "$LOG_FILE"
  fi
' >/dev/null 2>&1 &

runner_pid=$!
echo "$runner_pid" > "$PID_FILE"
echo "Runner PID: $(cat "$PID_FILE") (PID file: $PID_FILE)"
echo "asr is RUNNING in: $TARGET_DIR"
if [[ -n "${param:-}" ]]; then
  echo "Watch logs: asr tail \"$param\"    |    Stop: asr kill \"$param\""
else
  echo "Watch logs: asr tail               |    Stop: asr kill"
fi
echo "Log file: $LOG_FILE"

# parent exits immediately; child session owns lifecycle & cleanup
exit 0
